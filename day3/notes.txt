input could be packed in up to 4 vX.16b simd registers

1st 12 bit number v                                               v second 12 bit number start
"0", "1", "1", "0", "0", "1", "1", "0", "0", "1", "1", "0", ||  "0", "1", "1", "0"

                                            v third 12 bit number start
"1", "0", "0", "0", "1", "0", "0", "0", || "1", "0", "0", "0", "1", "0", "0", "0",  

                       v fourth 12 bit number start
"0", "0", "1", "1", || "0", "0", "1", "1", "0", "0", "1", "1", "0", "0", "1", "1",

3 registers gives us a relatively headache free layout that also happens
to divide our input number of lines (1000), so we can just do 250 loops


now we unsigned compare equal each to a 16b vector packed with the
ascii value for "1" which is 49. 

this sets each byte where there is a "1" to 255 (all 1's) and
"0" to 0 (all 0's)

meanwhile we have 12 ongoing counters for each bit position stored in 2 H
registers. like this:

v10 = bit1, bit2,  bit3,  bit4, bit5, bit6, bit7, bit8
v11 = bit9, bit10, bit11, bit12 0     0     0     0

so we need to sum our weird arrangment of 4 12 bit numbers 
